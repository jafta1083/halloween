import random
import json
import os
import sys
import time
import signal
from typing import List, Dict, Optional
from datetime import datetime

# ASCII Art
HALLOWEEN_TITLE = r"""
 __    __       ___       __       __        ______   ____    __    ____  _______ ____    __    ____  __  
|  |  |  |     /   \     |  |     |  |      /  __  \  \   \  /  \  /   / |   ____|\   \  /  \  /   / |  | 
|  |__|  |    /  ^  \    |  |     |  |     |  |  |  |  \   \/    \/   /  |  |__    \   \/    \/   /  |  | 
|   __   |   /  /_\  \   |  |     |  |     |  |  |  |   \            /   |   __|    \            /   |  | 
|  |  |  |  /  _____  \  |  `----.|  `----.|  `--'  |    \    /\    /    |  |____    \    /\    /    |__| 
|__|  |__| /__/     \__\ |_______||_______| \______/      \__/  \__/     |_______|    \__/  \__/     (__) 
"""

GHOST = r"""
    .-.
   (o o)
   | O \
    \   \
     `~~~'
"""

PUMPKIN = r"""
     ____
    |    |
   /      \
  |  O  O  |
  |   ^    |
   \  --  /
    `----'
"""

class TimeoutException(Exception):
    pass


def _timeout_handler(signum, frame):
    raise TimeoutException()

class HalloweenQuiz:
    def __init__(self):
        self.categories = {
            'spooky': 'Spooky Stories and Urban Legends',
            'costumes': 'Halloween Costumes and Traditions',
            'movies': 'Horror Movies and Characters',
            'history': 'Halloween History and Facts'
        }
        self.difficulties = ['easy', 'medium', 'hard']
        self.score = 0
        self.player_name = ""
        self.selected_categories: List[str] = []
        self.selected_difficulty = "medium"
        self.time_limit = 30  # seconds per question
        self.questions: Dict[str, List[Dict]] = {}
        self._load_questions()

    def _load_questions(self):
        """Load questions from the JSON file."""
        questions_file = os.path.join(os.path.dirname(__file__), '../assets/questions.json')
        try:
            with open(questions_file, 'r') as f:
                self.questions = json.load(f)
        except Exception as e:
            print(f"Could not load questions file: {e}")
            self.questions = {}

    def welcome_screen(self):
        print(HALLOWEEN_TITLE)
        print(GHOST)
        print("\nüéÉ Welcome to the Halloween Quiz! üéÉ")
        print("=" * 40)
        try:
            self.player_name = input("Enter your name, brave soul: ")
        except EOFError:
            self.player_name = "Player"
        if not self.player_name:
            self.player_name = "Player"
        print(f"\nWelcome {self.player_name}! Get ready for some spooky fun!")

        # Select difficulty
        print("\nSelect difficulty level:")
        for i, diff in enumerate(self.difficulties, 1):
            print(f"{i}. {diff.title()}")
        while True:
            try:
                choice = input("\nEnter difficulty (1-3): ")
                if not choice:
                    choice = '2'  # default medium
                choice_i = int(choice)
                if 1 <= choice_i <= 3:
                    self.selected_difficulty = self.difficulties[choice_i - 1]
                    break
                print("Please enter a number between 1 and 3.")
            except ValueError:
                print("Please enter a valid number.")

        # Set time limit based on difficulty
        self.time_limit = {"easy": 45, "medium": 30, "hard": 20}[self.selected_difficulty]

    def select_categories(self):
        """Let player choose quiz categories."""
        print("\nSelect categories to include in your quiz:")
        for key, name in self.categories.items():
            while True:
                choice = input(f"Include {name}? (y/n): ").strip().lower()
                if choice in ('y', 'n'):
                    if choice == 'y':
                        self.selected_categories.append(key)
                    break
                print("Please answer y or n.")

        if not self.selected_categories:
            print("No categories selected. Including all categories by default!")
            self.selected_categories = list(self.categories.keys())

    def get_category_questions(self) -> List[Dict]:
        """Get questions from selected categories based on difficulty."""
        selected_questions: List[Dict] = []
        for category in self.selected_categories:
            category_questions = self.questions.get(category, [])
            difficulty_questions = [q for q in category_questions if q.get('difficulty', 'medium') == self.selected_difficulty]
            selected_questions.extend(difficulty_questions)

        if not selected_questions:  # Fallback if no questions for selected difficulty
            for category in self.selected_categories:
                selected_questions.extend(self.questions.get(category, []))

        random.shuffle(selected_questions)
        return selected_questions[:10]

    def display_question(self, question: Dict, question_num: int) -> Optional[int]:
        """Display a single question and get player's answer with time limit.

        Uses Unix signal alarm to enforce timeout. On non-Unix platforms the timeout
        is disabled and input will block until the user responds.
        """
        print(f"\nQuestion {question_num}:")
        print(question['question'])
        print("\nOptions:")
        for idx, option in enumerate(question['options'], 1):
            print(f"{idx}. {option}")

        # Show time limit
        print(f"\nYou have {self.time_limit} seconds to answer.")

        # Setup timeout (Unix only)
        timeout_supported = hasattr(signal, 'SIGALRM')
        if timeout_supported:
            signal.signal(signal.SIGALRM, _timeout_handler)
            signal.alarm(self.time_limit)

        try:
            ans_raw = input("\nYour answer (enter the option number): ")
            if ans_raw is None:
                return None
            ans = int(ans_raw.strip())
            if 1 <= ans <= len(question['options']):
                return ans
            else:
                print("Invalid option number.")
                return None
        except TimeoutException:
            print("\n‚è∞ Time's up!")
            return None
        except (ValueError, EOFError):
            return None
        finally:
            if timeout_supported:
                signal.alarm(0)  # cancel alarm

    def play_game(self):
        self.welcome_screen()
        self.select_categories()

        questions = self.get_category_questions()
        total_questions = len(questions)

        print(f"\nüéÉ Get ready, {self.player_name}! Your spooky quiz begins now! üéÉ")
        print(PUMPKIN)
        print(f"Difficulty: {self.selected_difficulty.title()}")
        print(f"Time limit per question: {self.time_limit} seconds")
        input("\nPress Enter to start the quiz...")

        for i, question in enumerate(questions, 1):
            player_answer = self.display_question(question, i)

            if player_answer is None:
                print("\n‚è∞ Time's up or no valid answer. Moving to next question...")
                continue

            if question['options'][player_answer - 1] == question['correct_answer']:
                print("\n‚ú® Correct! You're scarily good at this!")
                # Bonus points based on difficulty
                bonus = {"easy": 1, "medium": 2, "hard": 3}[self.selected_difficulty]
                self.score += bonus
            else:
                print(f"\nüëª Oops! The correct answer was: {question['correct_answer']}")

            max_score_per_q = {"easy": 1, "medium": 2, "hard": 3}[self.selected_difficulty]
            print(f"Current Score: {self.score}/{i * max_score_per_q}")
            input("\nPress Enter to continue...")

        self.display_final_score(total_questions)

    def display_final_score(self, total_questions: int):
        max_possible_score = total_questions * {"easy": 1, "medium": 2, "hard": 3}[self.selected_difficulty]

        print("\n" + "=" * 40)
        print(GHOST if self.score < max_possible_score / 2 else PUMPKIN)
        print(f"üéÉ Game Over, {self.player_name}! üéÉ")
        print(f"Difficulty: {self.selected_difficulty.title()}")
        print(f"Final Score: {self.score}/{max_possible_score}")

        percentage = (self.score / max_possible_score) * 100 if max_possible_score > 0 else 0
        if percentage == 100:
            print("üèÜ PERFECT SCORE! You're the Ultimate Halloween Master! üëë")
            print("The spirits themselves bow to your knowledge!")
        elif percentage >= 80:
            print("üåü Impressive! You're truly a Halloween expert!")
            print("The ancient ones would be proud!")
        elif percentage >= 60:
            print("üéÉ Good job! You know your spooky stuff!")
            print("The spirits are pleased with your knowledge!")
        else:
            print("üëª Keep practicing! The spirits will guide you!")
            print("Every shadow holds a lesson to be learned...")

        # Save high score
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        score_line = f"{self.player_name},{self.selected_difficulty},{self.score}/{max_possible_score},{percentage:.1f}%,{now}\n"
        try:
            write_header = not os.path.exists("high_scores.csv")
            with open("high_scores.csv", "a") as f:
                if write_header:
                    f.write("Name,Difficulty,Score,Percentage,Date\n")
                f.write(score_line)
        except Exception:
            pass  # Silently fail if we can't save the score

if __name__ == "__main__":
    game = HalloweenQuiz()
    game.play_game()


    def play_game(self):
        """Main game loop."""
        self.welcome_screen()
                        self._play_sound('correct')
        self.select_categories()
        
        questions = self.get_category_questions()
        total_questions = len(questions)
        
                        self._play_sound('wrong')
        print(f"\nüéÉ Get ready, {self.player_name}! Your spooky quiz begins now! üéÉ")
        print(PUMPKIN)
        print(f"Difficulty: {self.selected_difficulty.title()}")
        print(f"Time limit per question: {self.time_limit} seconds")
        input("\nPress Enter to start the quiz...")
        
        for i, question in enumerate(questions, 1):
            player_answer = self.display_question(question, i)
            
            if player_answer is None:
                print("\n‚è∞ Time's up! Moving to next question...")
                continue
                
            if question['options'][player_answer - 1] == question['correct_answer']:
                print("\n‚ú® Correct! You're scarily good at this!")
                # Bonus points based on difficulty
                bonus = {"easy": 1, "medium": 2, "hard": 3}[self.selected_difficulty]
                    self._play_sound('win')
                self.score += bonus
            else:
                print(f"\nüëª Oops! The correct answer was: {question['correct_answer']}")
                    self._play_sound('win')
            
            print(f"Current Score: {self.score}/{i * {'easy': 1, 'medium': 2, 'hard': 3}[self.selected_difficulty]}")
            input("\nPress Enter to continue...")

        self.display_final_score(total_questions)

                    self._play_sound('lose')
    def display_final_score(self, total_questions: int):
        """Display the final score and a personalized message."""
        max_possible_score = total_questions * {"easy": 1, "medium": 2, "hard": 3}[self.selected_difficulty]
        
        print("\n" + "=" * 40)
        print(GHOST if self.score < max_possible_score/2 else PUMPKIN)
        print(f"üéÉ Game Over, {self.player_name}! üéÉ")
        print(f"Difficulty: {self.selected_difficulty.title()}")
        print(f"Final Score: {self.score}/{max_possible_score}")
        
        percentage = (self.score / max_possible_score) * 100
        if percentage == 100:
            print("üèÜ PERFECT SCORE! You're the Ultimate Halloween Master! üëë")
            print("The spirits themselves bow to your knowledge!")
        elif percentage >= 80:
            print("üåü Impressive! You're truly a Halloween expert!")
            print("The ancient ones would be proud!")
        elif percentage >= 60:
            print("üéÉ Good job! You know your spooky stuff!")
            print("The spirits are pleased with your knowledge!")
        else:
            print("üëª Keep practicing! The spirits will guide you!")
            print("Every shadow holds a lesson to be learned...")
        
        # Save high score
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        score_line = f"{self.player_name},{self.selected_difficulty},{self.score}/{max_possible_score},{percentage:.1f}%,{now}\n"
        try:
            with open("high_scores.csv", "a") as f:
                if not os.path.exists("high_scores.csv"):
                    f.write("Name,Difficulty,Score,Percentage,Date\n")
                f.write(score_line)
        except:
            pass  # Silently fail if we can't save the score

if __name__ == "__main__":
    game = HalloweenQuiz()
    game.play_game()